# **Proyecto: An치lisis de la activaci칩n de m칰sculos extensores y flexores del antebrazo durante tareas de mecanograf칤a y clickeo en poblaci칩n de estudiantes universitarios con y sin actividad f칤sica regular.**

## **Introducci칩n**
La digitalizaci칩n ha impulsado un uso cada vez m치s intensivo de dispositivos electr칩nicos como computadoras, laptops y tablets. Actividades rutinarias como la mecanograf칤a (proceso de introducir texto o caracteres alfanum칠ricos) y el uso del mouse, en especial el clic repetitivo (Los clicks por segundo (CPS) son una m칠trica fundamental que se utiliza para evaluar la velocidad y la agilidad de los movimientos de los dedos), se han convertido en tareas fundamentales tanto en contextos acad칠micos como profesionales. Estas acciones implican una repetici칩n constante de movimientos finos de los dedos y la mu침eca, lo que provoca una activaci칩n sostenida de los m칰sculos flexores y extensores del antebrazo, aumentando el riesgo de fatiga muscular y posibles trastornos musculoesquel칠ticos.[1][2]

El uso de computadoras y otros dispositivos se encuentra en su nivel m치s alto hasta la fecha y se espera que contin칰e aumentando a medida que la tecnolog칤a se vuelva m치s accesible.[3]

Se considera que los movimientos r치pidos y repetitivos de los dedos al usar el teclado y/o la carga muscular est치tica y las posturas al usar el rat칩n son factores de riesgo importantes para los TME relacionados con las computadoras. El uso del mouse proporciona cierta evidencia fisiol칩gica que puede explicar por qu칠 el uso del mouse tiene una mayor asociaci칩n con lesiones relacionadas con la computadora.[4]

No obstante, no todas las personas expuestas a estas tareas repetitivas desarrollan s칤ntomas con la misma intensidad. Diversos estudios sugieren que la pr치ctica regular de actividad f칤sica podr칤a desempe침ar un rol protector frente a la fatiga y los trastornos musculoesquel칠ticos. Por ejemplo, se ha encontrado que el ejercicio mejora la funci칩n ejecutiva y el rendimiento motor, incluso en tareas como la mecanograf칤a [5]. Adem치s, despu칠s de actividad f칤sica moderada, se observa un aumento en la velocidad de tipeo sin comprometer la precisi칩n [6]. Sin embargo, se ha reportado una preocupante disminuci칩n en los niveles de actividad f칤sica, especialmente entre j칩venes peruanos, lo cual podr칤a incrementar su vulnerabilidad frente al uso prolongado de dispositivos electr칩nicos [7].

En este contexto, nuestra investigaci칩n busca comparar el desempe침o en tareas de mecanograf칤a y clickeo entre personas f칤sicamente activas y aquellas que no realizan actividad f칤sica regular. El objetivo es identificar si existen diferencias significativas en la velocidad, precisi칩n y signos de fatiga, lo que podr칤a evidenciar el rol modulador de la condici칩n f칤sica sobre los efectos del uso repetitivo de dispositivos tecnol칩gicos. Con ello, se espera aportar evidencia que relacione el estilo de vida activo con una mejor tolerancia a las exigencias digitales cotidianas.


### **Estad칤sticas**
Tiempo de uso de computadoras durante el uso de recursos acad칠micos en una biblioteca.

![](imagenes/img_1.png)

### **Definici칩n de la problem치tica**
La fatiga muscular por uso prolongado de ordenadores ya sean port치tiles o de escritorio suponen una reducci칩n en la eficiencia del prop칩sito de su uso. Las actividades que involucran el uso de los ordenadores son frecuentes tanto en entornos laborales como educativos, y su pr치ctica prolongada puede inducir sobrecarga muscular, especialmente en los m칰sculos del antebrazo, mu침eca y mano.

## **Soluciones actuales**

1. Una revisi칩n sistem치tica de las aplicaciones de EMG para la caracterizaci칩n de la actividad muscular del antebrazo y la mano durante las actividades de la vida diaria: resultados, desaf칤os y cuestiones abiertas. (https://pmc.ncbi.nlm.nih.gov/articles/PMC8123433/)

2. Un estudio de la actividad muscular del antebrazo y la cinem치tica de la mu침eca en trabajadores de oficina sintom치ticos que realizan tareas de clic del mouse con diferentes exigencias de precisi칩n y velocidad. (https://pubmed.ncbi.nlm.nih.gov/20643564/)

3. Evaluaci칩n electromiogr치fica de la fatiga muscular: una profundizaci칩n en la actividad de mecanograf칤a repetitiva. (https://www.sciencedirect.com/science/article/abs/pii/S1050641104000422)

4. Examen basado en el nivel de habilidad de la activaci칩n de los m칰sculos del antebrazo asociado con movimientos eficientes de la mu침eca y los dedos al escribir. (https://www.sciencedirect.com/science/article/pii/S016981412300063X)

5. Impacto de los clics repetitivos del mouse en la fatiga muscular del antebrazo y el rendimiento de la punter칤a del mouse. (https://www.sciencedirect.com/science/article/pii/S0003687024000619)

## **Propuesta de soluci칩n**
Se plantea la realizaci칩n de un estudio de electromiograf칤a para evaluar y comparar la activaci칩n muscular de los m칰sculos extensores y flexores del antebrazo durante tareas de mecanograf칤a y clickeo en estudiantes universitarios activos f칤sicamente y sedentarios.

## **Metodolog칤a**
### **Participantes**
El estudio contar치 con la participaci칩n de un total de 6 estudiantes matriculados en el curso "Introducci칩n a las Se침ales Biom칠dicas" de la Universidad Peruana Cayetano Heredia (UPCH), con edades entre los 20-24 a침os. Los participantes ser치n clasificados seg칰n el nivel de actividad f칤sica utilizando el Cuestionario Internacional de Actividad F칤sica (IPAQ). A partir de los resultados del cuestionario, ser치n agrupados en dos categor칤as: Activos f칤sicamente (Categor칤a 3), quienes cumplen completamente con las recomendaciones de actividad f칤sica y sedentarios (Categor칤a 1), quienes no cumplen con las recomendaciones m칤nimas. Cada grupo tendr치 una muestra de 3 participantes. 
Los participantes deber치n firmar un consentimiento informado antes de participar en el estudio.

#### **Criterios de Exclusi칩n**
Estudiantes con lesiones musculoesquel칠ticas en la zona del antebrazo actuales o pasadas que puedan interferir con la activaci칩n muscular del antebrazo.

#### **Cuestionario validado para clasificar a los participantes seg칰n su nivel de actividad f칤sica**

Cuestionario Internacional de actividad f칤sica (IPAQ): (https://dialnet.unirioja.es/descarga/articulo/5920688.pdf)

Eval칰a el nivel de actividad f칤sica de adultos entre 18 y 65 a침os en los 칰ltimos 7 d칤as. Se utiliza para categorizar la actividad f칤sica en niveles (bajo, moderado o alto). Cuenta con dos versiones, la versi칩n corta de 7 preguntas y la versi칩n larga de 27 preguntas.

- Versi칩n corta: Eval칰a la frecuencia, duraci칩n e intensidad de la actividad f칤sica intensa, moderada, caminata y tiempo sentado. Es la versi칩n m치s sencilla y recomendada para investigaciones.
  - Aspectos clave:
    - Frecuencia: D칤as por semana de cada actividad
    - Duraci칩n: Tiempo por d칤a de cada actividad
  
  - El tiempo se mide en Mets (Unidades de 칈ndice Metab칩lico), con valores de referencia:
    - Caminar: 3.3 Mets.
    - Actividad moderada: 4 Mets.
    - Actividad vigorosa: 8 Mets.
    - n춿 Mets. = Actividad * d칤as * minutos 

![](imagenes/img_2.png)

  - Niveles de actividad f칤sica:
    - Bajo: No cumple con las recomendaciones de actividad f칤sica.
    - Moderado: Cumple parcialmente
    - Alto: Cumple completamente con las recomendaciones

![](imagenes/img_3.png)

### **Actividades a realizar**

- Mecanograf칤a:
  - 15 min de mecanograf칤a en una de las siguientes aplicaciones: https://agilefingers.com/es/test
  https://www.keybr.com/es/ 
  - Se medir치 la actividad muscular en los 2 primeros y finales minutos de la realizaci칩n de la mecanograf칤a

- Clicks:
  - Se realizar치n 2 actividades posibles durante 5 minutos cada uno y 2 minutos de descanso:
    - Primera actividad: Clickear el mouse para diferentes objetivos (Flappy Bird, Dinosaur Game o Piano Tiles)
    - Segunda actividad:  Clickear lo m치s r치pido posible (https://orteil.dashnet.org/cookieclicker/) 
    - Tercera actividad: Clickear por tiempos.

  - Se medir치 la actividad muscular en los 2 primeros y finales minutos de las actividades.


### **Protocolo de Adquisici칩n de Se침ales**
#### **Materiales**
Para hacer las mediciones, se utilizar치n 2 Bitalinos por persona.


### **Procesamiento de Se침ales**
#### **C칩digo**

```
import os
import numpy as np
import h5py
import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from torch.utils.data import Dataset, DataLoader, random_split
from scipy.signal import butter, filtfilt
from sklearn.metrics import classification_report, accuracy_score, f1_score

# === GPU o CPU ===
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Usando dispositivo: {device}")

# === CONFIGURACI칍N ===
FS = 1000  # Hz
VENTANA = 1000  # 1 segundo
RUTAS = {
    "FLEXOR": r"C:\Users\Christian\Documents\SE칌ALES\FLEXOR",
    "EXTENSOR": r"C:\Users\Christian\Documents\SE칌ALES\EXTENSOR"
}

# === FILTRADO DE SE칌AL EMG ===
def filtrar_emg(senal, fs=1000, low=20, high=450):
    b, a = butter(4, [low / (fs / 2), high / (fs / 2)], btype='band')
    return filtfilt(b, a, senal)

# === DATASET PERSONALIZADO ===
class EMGDataset(Dataset):
    def __init__(self, rutas, ventana=1000):
        self.samples = []

        for musculo, ruta in rutas.items():
            for sujeto in os.listdir(ruta):
                path_sujeto = os.path.join(ruta, sujeto)
                if not os.path.isdir(path_sujeto): continue

                for archivo in os.listdir(path_sujeto):
                    if archivo.endswith(".h5") and ("princ" in archivo or "inicio" in archivo or "final" in archivo):
                        etiqueta = 1 if "final" in archivo else 0
                        ruta_archivo = os.path.join(path_sujeto, archivo)
                        try:
                            with h5py.File(ruta_archivo, 'r') as f:
                                root = list(f.keys())[0]
                                senal = np.array(f[root + "/raw/channel_1"]).flatten()
                                senal = filtrar_emg(senal)

                                # Ventaneo
                                num_ventanas = len(senal) // ventana
                                for i in range(num_ventanas):
                                    segmento = senal[i*ventana:(i+1)*ventana]
                                    self.samples.append((segmento.astype(np.float32), etiqueta))
                        except Exception as e:
                            print(f"Error en {archivo}: {e}")

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        x, y = self.samples[idx]
        return torch.tensor(x).unsqueeze(0), torch.tensor(y, dtype=torch.long)

# === MODELO CNN 1D ===
class CNN1D(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv1d(1, 16, kernel_size=5, padding=2)
        self.bn1 = nn.BatchNorm1d(16)
        self.pool = nn.MaxPool1d(2)
        self.conv2 = nn.Conv1d(16, 32, kernel_size=5, padding=2)
        self.bn2 = nn.BatchNorm1d(32)
        self.fc1 = nn.Linear(32 * (VENTANA // 4), 64)
        self.fc2 = nn.Linear(64, 2)

    def forward(self, x):
        x = self.pool(torch.relu(self.bn1(self.conv1(x))))
        x = self.pool(torch.relu(self.bn2(self.conv2(x))))
        x = x.view(x.size(0), -1)
        x = torch.relu(self.fc1(x))
        return self.fc2(x)

# === ENTRENAMIENTO DEL MODELO ===
def entrenar_modelo(modelo, train_loader, val_loader, epochs=60):
    criterio = nn.CrossEntropyLoss()
    optimizador = optim.Adam(modelo.parameters(), lr=1e-3)

    loss_hist, acc_hist, f1_hist = [], [], []

    for epoch in range(epochs):
        modelo.train()
        losses = []
        for xb, yb in train_loader:
            xb, yb = xb.to(device), yb.to(device)
            optimizador.zero_grad()
            salida = modelo(xb)
            loss = criterio(salida, yb)
            loss.backward()
            optimizador.step()
            losses.append(loss.item())

        # === Validaci칩n ===
        modelo.eval()
        y_true, y_pred = [], []
        with torch.no_grad():
            for xb, yb in val_loader:
                xb, yb = xb.to(device), yb.to(device)
                out = modelo(xb)
                pred = out.argmax(dim=1)
                y_true.extend(yb.cpu().tolist())
                y_pred.extend(pred.cpu().tolist())

        acc = accuracy_score(y_true, y_pred)
        f1 = f1_score(y_true, y_pred)
        loss_mean = np.mean(losses)

        loss_hist.append(loss_mean)
        acc_hist.append(acc)
        f1_hist.append(f1)

        print(f"Epoch {epoch+1} - Loss: {loss_mean:.4f} - Val Acc: {acc:.3f} - Val F1: {f1:.3f}")

    print("\n=== 칔ltima evaluaci칩n ===")
    print(classification_report(y_true, y_pred))
    return loss_hist, acc_hist, f1_hist

# === CARGA Y DIVISI칍N DEL DATASET ===
dataset = EMGDataset(RUTAS, ventana=VENTANA)
train_size = int(0.8 * len(dataset))
val_size = len(dataset) - train_size
train_ds, val_ds = random_split(dataset, [train_size, val_size])

train_loader = DataLoader(train_ds, batch_size=32, shuffle=True)
val_loader = DataLoader(val_ds, batch_size=32)

# === INSTANCIAR Y ENTRENAR MODELO EN GPU ===
cnn = CNN1D().to(device)
losses, accs, f1s = entrenar_modelo(cnn, train_loader, val_loader, epochs=60)

# === GRAFICAR RESULTADOS ===
plt.figure(figsize=(10,4))
plt.subplot(1, 2, 1)
plt.plot(losses, label="Loss")
plt.title("Loss por 칠poca")
plt.xlabel("칄poca")
plt.ylabel("Loss")
plt.grid()
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(accs, label="Accuracy")
plt.plot(f1s, label="F1-score")
plt.title("Val Accuracy y F1")
plt.xlabel("칄poca")
plt.ylabel("Score")
plt.grid()
plt.legend()

plt.tight_layout()
plt.show()

# === GUARDAR MODELO (opcional) ===
# torch.save(cnn.state_dict(), "modelo_cnn_emg.pt")

```

```
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

def evaluar_matriz_confusion(modelo, val_loader):
    modelo.eval()
    y_true, y_pred = [], []

    with torch.no_grad():
        for xb, yb in val_loader:
            xb, yb = xb.to(device), yb.to(device)
            out = modelo(xb)
            pred = out.argmax(dim=1)
            y_true.extend(yb.cpu().tolist())
            y_pred.extend(pred.cpu().tolist())

    # Crear y mostrar matriz
    cm = confusion_matrix(y_true, y_pred)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=["No fatiga", "Fatiga"])
    disp.plot(cmap="Blues")
    plt.title("Matriz de Confusi칩n - CNN EMG")
    plt.grid(False)
    plt.show()

# 游댳 Llamar la funci칩n
evaluar_matriz_confusion(cnn, val_loader)
```

## **Referencias**

1. https://dapencentroestudios.com/importancia-mecanografia-por-ordenador/
2. https://elperiodicodeyecla.com/clicks-por-segundo-test-compruebe-que-tan-rapido-puede-hacer-clic/
3. http://scielo.senescyt.gob.ec/scielo.php?script=sci_arttext&pid=S2631-27862021000400023
4. https://pmc.ncbi.nlm.nih.gov/articles/PMC9798874/
5. https://www.biomedcentral.com/epdf/10.1186/1479-5868-8-98?sharing_token=m-57djXtO-MBCbJsHtDPcm_BpE1tBhCbnbw3BuzI2RN2QVl0o6IRGvx-oRNffeIDF9CYdA88GuExeEL3euE4kNTxLnpLM1Tsv3W8D_RJ5-OJffm9pQhd4O1zr_JuhgZcBO7pNcPzV8t2w2mdP50lOw%3D%3D 
6. https://pubmed.ncbi.nlm.nih.gov/39405599/ 
7. https://pubmed.ncbi.nlm.nih.gov/29791529/ 

